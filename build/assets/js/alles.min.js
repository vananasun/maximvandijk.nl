(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
let Grid = require('renderer/Grid.js');
let Texture = require('renderer/Texture.js');
let Fallback = require('renderer/Fallback.js');
let ShaderProgram = require('renderer/ShaderProgram.js');
let WebGLCanvas = require('renderer/WebGLCanvas.js');



const fps = {
    sampleSize : 60,
    value : 0,
    _sample_ : [],
    _index_ : 0,
    _lastTick_: false,
    tick : function(){
        // if is first tick, just set tick timestamp and return
        if( !this._lastTick_ ){
            this._lastTick_ = performance.now();
            return 0;
        }
        // calculate necessary values to obtain current tick FPS
        let now = performance.now();
        let delta = (now - this._lastTick_)/1000;
        let fps = 1/delta;
        // add to fps samples, current tick fps value
        this._sample_[ this._index_ ] = Math.round(fps);

        // iterate samples to obtain the average
        let average = 0;
        for(i=0; i<this._sample_.length; i++) average += this._sample_[ i ];

        average = Math.round( average / this._sample_.length);

        // set new FPS
        this.value = average;
        // store current timestamp
        this._lastTick_ = now;
        // increase sample index counter, and reset it
        // to 0 if exceded maximum sampleSize limit
        this._index_++;
        if( this._index_ === this.sampleSize) this._index_ = 0;
        return this.value;
    }
}



function render() {

    gl.clear(gl.COLOR_BUFFER_BIT);

    shader.bindMat4(shader.locateUniform("uProjection"), g_canvas.projectionMatrix);
    grid.render(performance.now());

    window.requestAnimationFrame(render);

}


function init() {
    g_canvas = new WebGLCanvas('back');
    if (!g_canvas)
        Fallback.NoWebGL();

    back = new Texture('assets/img/back04.jpg');

    shader = new ShaderProgram();
    shader.addStage(document.getElementById('vert').innerHTML, gl.VERTEX_SHADER);
    shader.addStage(document.getElementById('frag').innerHTML, gl.FRAGMENT_SHADER);
    shader.link();

    grid = new Grid(shader);
    grid.bindTexture(back);

    render();
}

init();

},{"renderer/Fallback.js":2,"renderer/Grid.js":3,"renderer/ShaderProgram.js":4,"renderer/Texture.js":5,"renderer/WebGLCanvas.js":6}],2:[function(require,module,exports){
Fallback = {};
Fallback.NoWebGL = function() {
    // @TODO: create element image
    console.log("No canvas :()")
}

module.exports = Fallback;

},{}],3:[function(require,module,exports){
let ShaderProgram = require("renderer/ShaderProgram.js");

// function generateUVs(divisions = 50) {
//     let uvs = new Float32Array(12 * divisions * divisions);
//     let index = 0;
//     for (let i = 0; i < divisions; i++) {
//         uvs[index++] = 0.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 1.0;
//
//         uvs[index++] = 0.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//     }
//     return uvs;
// }


function Grid(shader) {
    // generate buffers
    let vertices = this.generateVertices(1);
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    this.uvBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // prepare for using the given shader
    let oldShader = shader.use();
    this.locVertices   = shader.locateAttrib("aVertices");
    this.locUVs        = shader.locateAttrib("aUVs");
    this.locSampler    = shader.locateUniform("uSampler");
    this.locPos        = shader.locateUniform("uPos");
    this.locSize       = shader.locateUniform("uSize");
    this.locTime       = shader.locateUniform("uTime");
    // this.locResolution = shader.locateUniform("uResolution");
    if (oldShader) oldShader.use();
    this.shader = shader;

}

/**
 * Generate a field of vertices.
 */
Grid.prototype.generateVertices = function(divisions = 50) {
    let vertices = new Float32Array(12 * divisions * divisions);
    let step = 1.0 / divisions;
    let index = 0;

    for (let x = 0.0; x < 1.0; x += step) {
        for (let y = 0.0; y < 1.0; y += step) {

            vertices[index++] = x;
            vertices[index++] = y;
            vertices[index++] = x + step;
            vertices[index++] = y;
            vertices[index++] = x + step;
            vertices[index++] = y + step;

            vertices[index++] = x;
            vertices[index++] = y;
            vertices[index++] = x + step;
            vertices[index++] = y + step;
            vertices[index++] = x;
            vertices[index++] = y + step;

        }
    }

    // calculate amount of vertices
    this.vertexCount = divisions * divisions * 6;

    return vertices;
}

Grid.prototype.bindTexture = function(texture) {
    this.texture = texture;
}

Grid.prototype.render = function(time) {
    if (!this.texture.loaded) return;
    let oldShader = this.shader.use();

    // bind vertices
    gl.enableVertexAttribArray(this.locVertices);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(this.locVertices, 2, gl.FLOAT, false, 0, 0);

    // bind uvs
    gl.enableVertexAttribArray(this.locUVs);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.vertexAttribPointer(this.locUVs, 2, gl.FLOAT, false, 0, 0);

    // bind other uniforms
    let drawHeight = gl.drawingBufferWidth / this.texture.getAspect();
    this.shader.bind1f(this.locTime, time);
    this.shader.bind2f(this.locPos, 0, 0);
    this.shader.bind2f(this.locSize, gl.drawingBufferWidth, drawHeight);

    // bind texture and draw
    this.shader.bindSampler(this.locSampler, this.texture.id);
    gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
    if (oldShader) oldShader.use();
}



module.exports = Grid;

},{"renderer/ShaderProgram.js":4}],4:[function(require,module,exports){
/**
 * Usage order:
 * - new ShaderProgram object
 * - add stages
 * - link stages
 * - use ShaderProgram
 *
 * @author Maxim van Dijk
 */



/**
 * @constructor
 */
function ShaderProgram() {
    /** @member {WebGLProgram} */
    this.program = gl.createProgram();
}

/**
 * @property {ShaderProgram} The currently bound shader.
 */
ShaderProgram.BoundShader = null;



/**
 * Add a stage to the shader program.
 *
 * @param {string} source GLSL code.
 * @param {number} shaderType [ gl.VERTEX_SHADER, gl.FRAGMENT_SHADER ]
 */
ShaderProgram.prototype.addStage = function(source, stage) {
    // Compile shader stage
    let shader = gl.createShader(stage);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        let type = stage == gl.VERTEX_SHADER ? 'vertex' : 'fragment';
        console.error('Error compiling '+type+' shader:\n'+gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }

    // Attach shader stage to program
    gl.attachShader(this.program, shader);
}

/**
 * Link shader program stages to complete the shader for usage.
 */
ShaderProgram.prototype.link = function() {
    gl.linkProgram(this.program);
    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        console.error('Error linking program "'+this.program+'": '+gl.getProgramInfoLog(this.program));
        gl.deleteProgram(this.program);
    }
}



/**
 * Find the location of the given attribute in the program.
 *
 * @param {string} name The attribute name.
 *
 * @return {number} Found attribute location, -1 on failure.
 */
ShaderProgram.prototype.locateAttrib = function(name) {
    let loc = gl.getAttribLocation(this.program, name);
    if (-1 == loc) console.error('Unable to find attribute "'+name+'"\'s location');
    return loc;
}

/**
 * Find the location of the given uniform in the program.
 *
 * @param {string} name The uniform name.
 *
 * @return {number} Found uniform location, -1 on failure.
 */
ShaderProgram.prototype.locateUniform = function(name) {
    let loc = gl.getUniformLocation(this.program, name);
    if (null == loc) {
        console.error('Unable to find uniform "'+name+'"\'s location');
        return -1;
    }
    return loc;
}

/**
 * Binds a texture sampler to the shader.
 *
 * @param {WebGLUniformLocation} loc     Sampler's uniform location.
 * @param {WebGLTexture}         texture The GL texture object.
 * @param {number}               unit    (optional) GL texture unit to bind to,
 *                                       value must be 0 + n.
 */
ShaderProgram.prototype.bindSampler = function(loc, texture, unit = 0) {
    gl.activeTexture(unit + gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(loc, unit); // funnily enough it has to be 0 + n in the shader
}

/** @TODO: Implement gl.vertexAttrib3f etc... */

/**
 * Bind float uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {number}               x
 */
ShaderProgram.prototype.bind1f = function(loc, x) {
    gl.uniform1f(loc, x);
}

/**
 * Bind vec2 uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {number}               x
 * @param {number}               y
 */
ShaderProgram.prototype.bind2f = function(loc, x, y) {
    gl.uniform2f(loc, x, y);
}

/**
 * Bind vec4 uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {number}               r
 * @param {number}               g
 * @param {number}               b
 * @param {number}               a
 */
ShaderProgram.prototype.bind4f = function(loc, r, g, b, a) {
    gl.uniform4f(loc, r, g, b, a);
}

/**
 * Bind 4x4 matrix to uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {Float32Array|array}   matrix
 */
ShaderProgram.prototype.bindMat4 = function(loc, matrix) {
    gl.uniformMatrix4fv(loc, false, matrix);
}



/**
 * Bind the shader.
 *
 * @return {ShaderProgram} Previously bound shader.
 */
ShaderProgram.prototype.use = function() {
    let old = ShaderProgram.BoundShader;
    gl.useProgram(this.program);
    ShaderProgram.BoundShader = this;
    return old ? old : this;
}



module.exports = ShaderProgram;

},{}],5:[function(require,module,exports){
let ShaderProgram = require("renderer/ShaderProgram.js");

/**
 * @constructor
 *
 * @param {string} url (optional)
 */
function Texture(url = null) {
    if (!url) return;
    this.loaded = false;

    // Create texture
    this.id = gl.createTexture();

    // Load image
    let self = this;
    this.image = new Image();
    this.image.src = url;
    this.image.addEventListener('load', function() {
        gl.bindTexture(gl.TEXTURE_2D, self.id);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, self.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        self.width = self.image.width;
        self.height = self.image.height;
        self.image = null;
        self.loaded = true;
    }, false);
}

Texture.prototype.getAspect = function() {
    if (!this.loaded) return 1.0;
    return this.width / this.height;
}

// Texture.prototype.makeRenderable = function(shader) {
//
//     let vertices = [
//         0.0, 0.0,
//         1.0, 0.0,
//         1.0, 1.0,
//         0.0, 0.0,
//         1.0, 1.0,
//         0.0, 1.0
//     ];
//
//     this.uvBuffer = gl.createBuffer();
//     gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
//     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
//
//     for (let i = 0; i < vertices.length; i++) vertices[i] *= 200.0;
//
//     this.vertexBuffer = gl.createBuffer();
//     gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
//     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
//
//     let oldShader = shader.use();
//     this.locVertices = shader.locateAttrib("aVertices");
//     this.locUVs = shader.locateAttrib("aUVs");
//     this.locSampler = shader.locateUniform("uSampler");
//     if (oldShader) oldShader.use();
//     this.shader = shader;
// }
//
// Texture.prototype.render = function() {
//     if (!this.loaded) return;
//     let oldShader = this.shader.use();
//
//     // Bind vertices
//     gl.enableVertexAttribArray(this.locVertices);
//     gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
//     gl.vertexAttribPointer(this.locVertices, 2, gl.FLOAT, false, 0, 0);
//
//     // Bind tex coords
//     gl.enableVertexAttribArray(this.locUVs);
//     gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
//     gl.vertexAttribPointer(this.locUVs, 2, gl.FLOAT, false, 0, 0);
//
//     // Bind texture to sampler
//     this.shader.bindSampler(this.locSampler, this.texture);
//
//     // Draw!
//     gl.drawArrays(gl.TRIANGLES, 0, 6);
//     if (oldShader) oldShader.use();
//
// }

module.exports = Texture;

},{"renderer/ShaderProgram.js":4}],6:[function(require,module,exports){
function WebGLCanvas(id) {
    this.canvas = document.getElementById(id);
    this.onWindowResize();
    let self = this;
    window.addEventListener("resize", function(){ self.onWindowResize() }, false);

    gl = this.canvas.getContext('webgl', {antialias: true});
    if (!gl) return false;

    // Settings
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    return true;
};


/**
 * Generates an orthogonal projection matrix with the given bounds
 *
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {array} out
*/
WebGLCanvas.ortho = function(left, right, bottom, top, near, far) {
    let out = new Float32Array(16);
    let lr = 1 / (left - right);
    let bt = 1 / (bottom - top);
    let nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}

WebGLCanvas.prototype.onWindowResize = function() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.projectionMatrix = WebGLCanvas.ortho(0,this.canvas.clientWidth, this.canvas.clientHeight,0, -1,1);
    if ('undefined' === typeof gl) return;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
};

WebGLCanvas.prototype.clearCanvas = function(self) {
    gl.clear(gl.COLOR_BUFFER_BIT);
};




module.exports = WebGLCanvas;

},{}]},{},[1]);
