(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const fps = {
    sampleSize : 60,
    value : 0,
    _sample_ : [],
    _index_ : 0,
    _lastTick_: false,
    tick : function() {
        // if is first tick, just set tick timestamp and return
        if( !this._lastTick_ ){
            this._lastTick_ = performance.now();
            return 0;
        }
        // calculate necessary values to obtain current tick FPS
        let now = performance.now();
        let delta = (now - this._lastTick_)/1000;
        let fps = 1/delta;
        // add to fps samples, current tick fps value
        this._sample_[ this._index_ ] = Math.round(fps);

        // iterate samples to obtain the average
        let average = 0;
        for(i=0; i<this._sample_.length; i++) average += this._sample_[ i ];

        average = Math.round( average / this._sample_.length);

        // set new FPS
        this.value = average;
        // store current timestamp
        this._lastTick_ = now;
        // increase sample index counter, and reset it
        // to 0 if exceded maximum sampleSize limit
        this._index_++;
        if( this._index_ === this.sampleSize) this._index_ = 0;
        return this.value;
    }
}

module.exports = fps;

},{}],2:[function(require,module,exports){
Fallback = {};
Fallback.NoWebGL = function() {
    // @TODO: create element image
    console.log("No webgl canvas :()")
}

module.exports = Fallback;

},{}],3:[function(require,module,exports){
function groet(country = 'nl') {
    const text = {
        'nl': {
            'night': 'Welkom nachtuil',
            'morning': 'Goedenmorgen',
            'afternoon': 'Goedemiddag',
            'evening': 'Goedenavond'
        },
        'en': {
            'night': 'Welcome nightowl',
            'morning': 'Good morning',
            'afternoon': 'Great afternoon',
            'evening': 'Good evening'
        }
    }

    let a = '';
    let hours = new Date().getHours();
    if (hours < 6) a = text[country]['night'];
    else if (hours < 12) a = text[country]['morning'];
    else if (hours < 18) a = text[country]['afternoon'];
    else a = text[country]['evening'];
    return a;
}

function leeftijd() {
    var birthday = +new Date('1999-05-20');
    return~~ ((Date.now() - birthday) / (31557600000));
}

function dia(country = 'nl') {
    const t = {
        'nl': {
            'day': 'dag',
            'night': 'nacht'
        },
        'en': {
            'day': 'day',
            'night': 'night'
        }
    };
    if (new Date().getHours() < 12) return t[country]['night'];
    else return t[country]['day'];
}

/*******************************************************************************
 *
 ******************************************************************************/



LocaleManager = function() {
    let _content = document.querySelector('.modal>div.active');
    if (!_content) return;

    switch (_content.id) {
    case 'content-over':
        let _spans = _content.querySelectorAll('span');
        _spans.forEach(_span => {
            if (_span.classList.contains('nl')) {
                _span.innerHTML = _span.innerHTML.replace('$groet', groet());
                _span.innerHTML = _span.innerHTML.replace('$leeftijd', leeftijd());
                _span.innerHTML = _span.innerHTML.replace('$dia', dia());
            } else {
                _span.innerHTML = _span.innerHTML.replace('$groet', groet('en'));
                _span.innerHTML = _span.innerHTML.replace('$leeftijd', leeftijd());
                _span.innerHTML = _span.innerHTML.replace('$dia', dia('en'));
            }
        });
        break;
    case 'content-projecten':
        break;
    case 'content-contact':
        break;
    }
}

LocaleManager.prototype.change = function(country) {
    const countries = [ 'nl', 'en' ];
    countries.forEach(c => document.body.classList.remove(c));
    document.body.classList.add(country);
}

module.exports = LocaleManager;

//
//
// new Locale({
//     '$groet': function() {
//
//     },
//
//     '$leeftijd': function() {
//         return 21;
//     }
//
//     '$dia': function() {
//         return 'dag';
//     }
//
// });

},{}],4:[function(require,module,exports){
Modal = function() {


}

Modal.prototype.changeTo = function(e) {
    let _active = document.querySelector('.modal>div.active')
    _active.classList.remove('active');

    let _content = document.getElementById('content-'+e.id);
    _content.classList.add('active');

}
// 
// Modal.prototype.applyLocale = function() {
//     // Modal
//     let _content = document.querySelector('.modal>div.active');
//     if (!_content) return;
//
//     switch (_content.id) {
//     case 'content-over':
//         let _spans = _content.querySelectorAll('span');
//         _spans.forEach(_span => {
//             _span.innerHTML = _span.innerHTML.replace('$groet', 'Hallo');
//             _span.innerHTML = _span.innerHTML.replace('$leeftijd', '21');
//         });
//         break;
//     case 'content-projecten':
//         break;
//     case 'content-contact':
//         break;
//     }
//
// }



module.exports = Modal;

},{}],5:[function(require,module,exports){
let Fallback = require('Fallback.js');
let g_fps = require('FPS.js');
let Modal = require('Modal.js');
let LocaleManager = require('LocaleManager.js');

let Grid = require('renderer/Grid.js');
let Texture = require('renderer/Texture.js');
let ShaderProgram = require('renderer/ShaderProgram.js');
let RectangleRenderer = require('renderer/RectangleRenderer.js');
let WebGLCanvas = require('renderer/WebGLCanvas.js');
let LazyLoader = require('renderer/LazyLoader.js');
let FilterAnimation = require('renderer/FilterAnimation.js');



const FADE_SPEED = 1 / 23;



function render(t) {

    g_canvas.clearCanvas();

    shader.bindMat4(shader.locateUniform("uProjection"), g_canvas.projectionMatrix);

    if (grid.render(t) && (g_fadeOpacity -= FADE_SPEED) > 0.0) {
        let fadeInColor = {r: 34 / 255, g: 28 / 255, b: 56 / 255, a: g_fadeOpacity};
        g_rectangleRenderer.draw(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, fadeInColor);
    }

    g_filterAnimation.update(t);

    window.requestAnimationFrame(render);

}


function init() {
    g_canvas = new WebGLCanvas('back');
    if (!g_canvas)
        Fallback.NoWebGL();
    g_rectangleRenderer = new RectangleRenderer();
    g_fadeOpacity = 1.0 - FADE_SPEED;


    // Lazily-load background texture
    back = new Texture();
    let backs = [
        'back01',
        'back02',
        'back03',
        'back04',
        'back05',
        'back06',
        'back07'
    ];
    let name = 'assets/img/lazy/' + backs[Math.floor(Math.random() * backs.length)];
    g_lazyLoader = new LazyLoader();
    g_lazyLoader.loadImage(name, function(img) {
        back.uploadImage(img);
    });

    // Setup background shader.
    shader = new ShaderProgram();
    shader.addStage(document.getElementById('vert').innerHTML, gl.VERTEX_SHADER);
    shader.addStage(document.getElementById('frag').innerHTML, gl.FRAGMENT_SHADER);
    shader.link();

    // Create the moving background object.
    grid = new Grid(shader);
    grid.bindTexture(back);

    // Initialize SVG filter animation.
    g_filterAnimation = new FilterAnimation();

    // Make modal and locale objects
    g_modal = new Modal();
    g_locale = new LocaleManager();

    render(0.0);
}

init();

},{"FPS.js":1,"Fallback.js":2,"LocaleManager.js":3,"Modal.js":4,"renderer/FilterAnimation.js":6,"renderer/Grid.js":7,"renderer/LazyLoader.js":8,"renderer/RectangleRenderer.js":9,"renderer/ShaderProgram.js":10,"renderer/Texture.js":11,"renderer/WebGLCanvas.js":12}],6:[function(require,module,exports){
FilterAnimation = function() {

    this._filter = document.getElementById('psy');
    this._feOffsets = this._filter.querySelectorAll('feOffset');

    this.origX = 2.8;
    this.origY = 0;

}

FilterAnimation.prototype.update = function(time) {

    let angle, x, y;

    angle = time / 684.0;
    x = Math.cos(angle) * this.origX - Math.sin(angle) * this.origY;
    y = Math.sin(angle) * this.origX + Math.cos(angle) * this.origY;
    this._feOffsets[0].setAttribute('dx', x);
    this._feOffsets[0].setAttribute('dy', y);

    angle = -(time / 746.4);
    x = Math.cos(angle) * this.origX - Math.sin(angle) * this.origY;
    y = Math.sin(angle) * this.origX + Math.cos(angle) * this.origY;
    this._feOffsets[1].setAttribute('dx', x);
    this._feOffsets[1].setAttribute('dy', y);

}

module.exports = FilterAnimation;

},{}],7:[function(require,module,exports){
let ShaderProgram = require("renderer/ShaderProgram.js");

// function generateUVs(divisions = 50) {
//     let uvs = new Float32Array(12 * divisions * divisions);
//     let index = 0;
//     for (let i = 0; i < divisions; i++) {
//         uvs[index++] = 0.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 1.0;
//
//         uvs[index++] = 0.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 1.0;
//         uvs[index++] = 0.0;
//         uvs[index++] = 1.0;
//     }
//     return uvs;
// }

/**
 * For a rectangle inside a screen, get the scale factor that permits the
 * rectangle to be scaled without stretching or squashing.
 *
 * @param {object} screen { {number} w, {number} h }
 * @param {object} img    { {number} w, {number} h }
 *
 * @return {object} rect { {number} x, {number} y, {number} w, {number} h }
 */
function fitRectInScreen(screen, img) {

    let imgRatio = img.h / img.w;
    let screenRatio = screen.h / screen.w;

    let final = {};
    if (screenRatio > imgRatio) {
        final.h = screen.h;
        final.w = Math.floor(img.w * (final.h / img.h));
    } else {
        final.w = screen.w;
        final.h = Math.floor(img.h * (final.w / img.w));
    }

    return {
        x: (screen.w - final.w) / 2,
        y: (screen.h - final.h) / 2,
        w: final.w,
        h: final.h
    };

}






function Grid(shader) {
    // generate buffers
    let vertices = this.generateVertices(1);
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    this.uvBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // prepare for using the given shader
    let oldShader = shader.use();
    this.locVertices   = shader.locateAttrib("aVertices");
    this.locUVs        = shader.locateAttrib("aUVs");
    this.locSampler    = shader.locateUniform("uSampler");
    this.locPos        = shader.locateUniform("uPos");
    this.locSize       = shader.locateUniform("uSize");
    this.locTime       = shader.locateUniform("uTime");
    if (oldShader) oldShader.use();
    this.shader = shader;

}

/**
 * Generate a field of vertices.
 */
Grid.prototype.generateVertices = function(divisions = 50) {
    let vertices = new Float32Array(12 * divisions * divisions);
    let step = 1.0 / divisions;
    let index = 0;

    for (let x = 0.0; x < 1.0; x += step) {
        for (let y = 0.0; y < 1.0; y += step) {

            vertices[index++] = x;
            vertices[index++] = y;
            vertices[index++] = x + step;
            vertices[index++] = y;
            vertices[index++] = x + step;
            vertices[index++] = y + step;

            vertices[index++] = x;
            vertices[index++] = y;
            vertices[index++] = x + step;
            vertices[index++] = y + step;
            vertices[index++] = x;
            vertices[index++] = y + step;

        }
    }

    // calculate amount of vertices
    this.vertexCount = divisions * divisions * 6;

    return vertices;
}

Grid.prototype.bindTexture = function(texture) {
    this.texture = texture;
}

Grid.prototype.render = function(time) {
    if (!this.texture.loaded) return false;
    let oldShader = this.shader.use();

    // bind vertices
    gl.enableVertexAttribArray(this.locVertices);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(this.locVertices, 2, gl.FLOAT, false, 0, 0);

    // bind uvs
    gl.enableVertexAttribArray(this.locUVs);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
    gl.vertexAttribPointer(this.locUVs, 2, gl.FLOAT, false, 0, 0);

    // bind other uniforms
    let rect = fitRectInScreen(
        { w: gl.drawingBufferWidth, h: gl.drawingBufferHeight },
        { w: this.texture.width   , h: this.texture.height
    });
    this.shader.bind1f(this.locTime, time / 3000.0);
    this.shader.bind2f(this.locPos , rect.x, rect.y);
    this.shader.bind2f(this.locSize, rect.w, rect.h);

    // bind texture and draw
    this.shader.bindSampler(this.locSampler, this.texture.id);
    gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);
    // if (oldShader) oldShader.use();
    return true;
}



module.exports = Grid;

},{"renderer/ShaderProgram.js":10}],8:[function(require,module,exports){

/*
 * @TODO: Add JPEG fallbacks.
 * @TODO: Add on-resize loading.
 */

function LazyLoader() {
    this.sizes = [
        [ 160 ,   90 ],
        [ 640 ,  360 ],
        [ 1024,  576 ],
        [ 1280,  720 ],
        [ 1920, 1080 ],
        [ 2560, 1440 ],
        [ 3200, 1800 ],
        [ 3840, 2160 ]
    ];

    for (let i = 0; i < this.sizes.length; i++) {
        this.maxSizeIndex = i;
        if (this.sizes[i][0] >= window.innerWidth
        &&  this.sizes[i][1] >= window.innerHeight)
            break;
    }
}

LazyLoader.prototype.loadImage = function(name, callback) {

    let ext = '.webp'; // @TODO: Add JPEG fallback.

    for (let sizeIndex = 0; sizeIndex < this.maxSizeIndex; sizeIndex++) {

        let size = this.sizes[sizeIndex][0] + 'x' + this.sizes[sizeIndex][1];
        let url = name + '_' + size + ext;

        let image = new Image();
        image.src = url;
        image.addEventListener('load', function() {

            callback(image);

        }, false);
    }

}

module.exports = LazyLoader;

},{}],9:[function(require,module,exports){
var ShaderProgram = require('renderer/ShaderProgram.js');



function RectangleRenderer() {
    this.shader = new ShaderProgram();
    this.shader.addStage(document.getElementById('rectVertex').innerHTML, gl.VERTEX_SHADER);
    this.shader.addStage(document.getElementById('rectFragment').innerHTML, gl.FRAGMENT_SHADER);
    this.shader.link();
    this.locVertices = this.shader.locateAttrib("aVertices");
    this.locProjection = this.shader.locateUniform("uProjection");
    this.locPos = this.shader.locateUniform("uPos");
    this.locColor = this.shader.locateUniform("uColor");

    let vertices = new Float32Array(12);
    vertices[0 ] = 0.0; vertices[1 ] = 0.0;
    vertices[2 ] = 1.0; vertices[3 ] = 0.0;
    vertices[4 ] = 1.0; vertices[5 ] = 1.0;
    vertices[6 ] = 0.0; vertices[7 ] = 0.0;
    vertices[8 ] = 1.0; vertices[9 ] = 1.0;
    vertices[10] = 0.0; vertices[11] = 1.0;
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

}


RectangleRenderer.prototype.draw = function(x, y, width, height, color = {r:0,g:255.0,b:128,a:0.4}) {
    let oldShader = this.shader.use();

    gl.enableVertexAttribArray(this.locVertices);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(this.locVertices, 2, gl.FLOAT, false, 0, 0);

    this.shader.bind4f(this.locPos, x, y, width, height);
    this.shader.bind4f(this.locColor, color.r, color.g, color.b, color.a);
    this.shader.bindMat4(this.locProjection, g_canvas.projectionMatrix);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    oldShader.use();
}

module.exports = RectangleRenderer;

},{"renderer/ShaderProgram.js":10}],10:[function(require,module,exports){
/**
 * Usage order:
 * - new ShaderProgram object
 * - add stages
 * - link stages
 * - use ShaderProgram
 *
 * @author Maxim van Dijk
 */



/**
 * @constructor
 */
function ShaderProgram() {
    /** @member {WebGLProgram} */
    this.program = gl.createProgram();
}

/**
 * @property {ShaderProgram} The currently bound shader.
 */
ShaderProgram.BoundShader = null;



/**
 * Add a stage to the shader program.
 *
 * @param {string} source GLSL code.
 * @param {number} shaderType [ gl.VERTEX_SHADER, gl.FRAGMENT_SHADER ]
 */
ShaderProgram.prototype.addStage = function(source, stage) {
    // Compile shader stage
    let shader = gl.createShader(stage);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        let type = stage == gl.VERTEX_SHADER ? 'vertex' : 'fragment';
        console.error('Error compiling '+type+' shader:\n'+gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }

    // Attach shader stage to program
    gl.attachShader(this.program, shader);
}

/**
 * Link shader program stages to complete the shader for usage.
 */
ShaderProgram.prototype.link = function() {
    gl.linkProgram(this.program);
    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        console.error('Error linking program "'+this.program+'": '+gl.getProgramInfoLog(this.program));
        gl.deleteProgram(this.program);
    }
}



/**
 * Find the location of the given attribute in the program.
 *
 * @param {string} name The attribute name.
 *
 * @return {number} Found attribute location, -1 on failure.
 */
ShaderProgram.prototype.locateAttrib = function(name) {
    let loc = gl.getAttribLocation(this.program, name);
    if (-1 == loc) console.error('Unable to find attribute "'+name+'"\'s location');
    return loc;
}

/**
 * Find the location of the given uniform in the program.
 *
 * @param {string} name The uniform name.
 *
 * @return {number} Found uniform location, -1 on failure.
 */
ShaderProgram.prototype.locateUniform = function(name) {
    let loc = gl.getUniformLocation(this.program, name);
    if (null == loc) {
        console.error('Unable to find uniform "'+name+'"\'s location');
        return -1;
    }
    return loc;
}

/**
 * Binds a texture sampler to the shader.
 *
 * @param {WebGLUniformLocation} loc     Sampler's uniform location.
 * @param {WebGLTexture}         texture The GL texture object.
 * @param {number}               unit    (optional) GL texture unit to bind to,
 *                                       value must be 0 + n.
 */
ShaderProgram.prototype.bindSampler = function(loc, texture, unit = 0) {
    gl.activeTexture(unit + gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(loc, unit); // funnily enough it has to be 0 + n in the shader
}

/** @TODO: Implement gl.vertexAttrib3f etc... */

/**
 * Bind float uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {number}               x
 */
ShaderProgram.prototype.bind1f = function(loc, x) {
    gl.uniform1f(loc, x);
}

/**
 * Bind vec2 uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {number}               x
 * @param {number}               y
 */
ShaderProgram.prototype.bind2f = function(loc, x, y) {
    gl.uniform2f(loc, x, y);
}

/**
 * Bind vec4 uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {number}               r
 * @param {number}               g
 * @param {number}               b
 * @param {number}               a
 */
ShaderProgram.prototype.bind4f = function(loc, r, g, b, a) {
    gl.uniform4f(loc, r, g, b, a);
}

/**
 * Bind 4x4 matrix to uniform.
 *
 * @param {WebGLUniformLocation} loc
 * @param {Float32Array|array}   matrix
 */
ShaderProgram.prototype.bindMat4 = function(loc, matrix) {
    gl.uniformMatrix4fv(loc, false, matrix);
}



/**
 * Bind the shader.
 *
 * @return {ShaderProgram} Previously bound shader.
 */
ShaderProgram.prototype.use = function() {
    let old = ShaderProgram.BoundShader;
    gl.useProgram(this.program);
    ShaderProgram.BoundShader = this;
    return old ? old : this;
}



module.exports = ShaderProgram;

},{}],11:[function(require,module,exports){
let ShaderProgram = require("renderer/ShaderProgram.js");

/**
 * @constructor
 */
function Texture() {
    this.loaded = false;
    this.id = gl.createTexture();
}

Texture.prototype.uploadImage = function(image) {
    gl.bindTexture(gl.TEXTURE_2D, this.id);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    this.width = image.width;
    this.height = image.height;
    this.loaded = true;
}

Texture.prototype.getAspect = function() {
    if (!this.loaded) return 1.0;
    return this.width / this.height;
}

module.exports = Texture;

},{"renderer/ShaderProgram.js":10}],12:[function(require,module,exports){
function WebGLCanvas(id) {
    this.canvas = document.getElementById(id);
    this.onWindowResize();
    let self = this;
    window.addEventListener("resize", function(){ self.onWindowResize() }, false);

    gl = this.canvas.getContext('webgl', {antialias: false});
    if (!gl) return false;

    // Settings
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(0,0,0,1);
    this.clearCanvas();
    return true;
};


/**
 * Generates an orthogonal projection matrix with the given bounds
 *
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {array} out
*/
WebGLCanvas.ortho = function(left, right, bottom, top, near, far) {
    let out = new Float32Array(16);
    let lr = 1 / (left - right);
    let bt = 1 / (bottom - top);
    let nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}

WebGLCanvas.prototype.onWindowResize = function() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.projectionMatrix = WebGLCanvas.ortho(0,this.canvas.clientWidth, this.canvas.clientHeight,0, -1,1);
    if ('undefined' === typeof gl) return;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
};

WebGLCanvas.prototype.clearCanvas = function(self) {
    gl.clear(gl.COLOR_BUFFER_BIT);
};




module.exports = WebGLCanvas;

},{}]},{},[5]);
